// f:\Fun\Dev\holodex-notifier\holodex-notifier\holodex_notifier\lib\infrastructure\data\database.dart
import 'dart:io';
import 'dart:convert'; // For JSON converter

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
// Import logger if needed, e.g., from main.dart provider
// import 'package:holodex_notifier/main.dart';

part 'database.g.dart'; // Generated by drift_dev builder

// --- Type Converters ---

// Converter for storing a list of strings as a JSON string
class StringListConverter extends TypeConverter<List<String>, String> {
  const StringListConverter();

  @override
  List<String> fromSql(String? fromDb) {
    if (fromDb == null || fromDb.isEmpty) {
      return [];
    }
    try {
      final decoded = json.decode(fromDb);
      if (decoded is List) {
        return List<String>.from(decoded.map((item) => item.toString()));
      }
      // TODO: Add actual logging
      print("StringListConverter WARN: Decoded DB value is not a List: $fromDb");
      return [];
    } catch (e) {
      // TODO: Add actual logging
      print("StringListConverter ERROR decoding from DB: $e, value: $fromDb");
      return [];
    }
  }

  @override
  String toSql(List<String> value) {
    return json.encode(value);
  }
}

// --- Table Definition ---
@DataClassName('CachedVideo')
class CachedVideos extends Table {
  // Primary Key
  TextColumn get videoId => text().named('video_id')();
  TextColumn get channelId => text().named('channel_id').withDefault(const Constant('Unknown'))();
  // --- Core fields synced from API ---
  TextColumn get status => text().named('status')();
  TextColumn? get startScheduled => text().named('start_scheduled').nullable()();
  TextColumn? get startActual => text().named('start_actual').nullable()();
  TextColumn get availableAt => text().named('available_at')();
  TextColumn? get videoType => text().named('video_type').nullable()(); // Added video type
  TextColumn? get certainty => text().named('certainty').nullable()();
  TextColumn get mentionedChannelIds => text().named('mentioned_channel_ids').map(const StringListConverter()).withDefault(const Constant('[]'))();
  TextColumn get videoTitle => text().named('video_title').withDefault(const Constant('Unknown Title'))();
  TextColumn get channelName => text().named('channel_name').withDefault(const Constant('Unknown Channel'))();
  TextColumn? get channelAvatarUrl => text().named('channel_avatar_url').nullable()();

  // --- Internal Processing State ---
  BoolColumn get isPendingNewMediaNotification => boolean().named('is_pending_new_media_notification').withDefault(const Constant(false))();
  IntColumn get lastSeenTimestamp => integer().named('last_seen_timestamp')(); // When poller last saw this video's data
  IntColumn? get scheduledLiveNotificationId =>
      integer().named('scheduled_live_notification_id').nullable()(); // Platform notification ID if scheduled
  IntColumn? get lastLiveNotificationSentTime => integer().named('last_live_notification_sent_time').nullable()(); // Debounce for immediate live
  IntColumn? get scheduledReminderNotificationId => integer().named('scheduled_reminder_notification_id').nullable()(); // Platform ID for reminder
  IntColumn? get scheduledReminderTime => integer().named('scheduled_reminder_time').nullable()(); // Calculated timestamp for reminder

  // REMOVED: lastProcessedTimestamp is no longer needed with the new architecture

  @override
  Set<Column> get primaryKey => {videoId};
}

// --- Database Class ---
@DriftDatabase(tables: [CachedVideos])
class AppDatabase extends _$AppDatabase {
  AppDatabase(super.e);

  // --- INCREMENT SCHEMA VERSION ---
  @override
  int get schemaVersion => 1; //leaving at 1 during alpha dev phase, do not change

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) async {
      await m.createAll();
      // TODO: Use actual logger
      print("Drift DB [v$schemaVersion]: Tables created.");
    },
    onUpgrade: (Migrator m, int from, int to) async {
      // TODO: Use actual logger
      print("Drift DB: Upgrading schema from v$from to v$to...");
      if (from == 1 && to == 2) {
        // placeholder, do not add migration strategy until dev is out of alpha phase
      }
      // Add more migrations here using `if (from <= X) { ... }` blocks
    },
    beforeOpen: (details) async {
      // TODO: Use actual logger
      print(
        "Drift DB: Opening database. Was Created: ${details.wasCreated}, Version Before: ${details.versionBefore}, Current Version: ${details.versionNow}",
      );
      await customStatement('PRAGMA foreign_keys = ON;');
    },
  );

  // --- CRUD Methods ---

  Future<CachedVideo?> getVideo(String id) {
    return (select(cachedVideos)..where((t) => t.videoId.equals(id))).getSingleOrNull();
  }

  Future<void> upsertVideo(CachedVideosCompanion entry) {
    // Use the generated insertOnConflictUpdate method
    return into(cachedVideos).insertOnConflictUpdate(entry);
  }

  Future<void> deleteVideo(String id) {
    return (delete(cachedVideos)..where((t) => t.videoId.equals(id))).go();
  }

  // --- Specific Queries & Updates ---

  Future<List<CachedVideo>> getVideosByStatus(String statusFilter) {
    return (select(cachedVideos)..where((t) => t.status.equals(statusFilter))).get();
  }

  // --- Pruning ---
  Future<int> prunePastVideos() async {
    // Deletes videos where status is 'past'
    final count = await (delete(cachedVideos)..where((t) => t.status.equals('past'))).go();
    // TODO: Use actual logger
    print("Pruned $count 'past' videos.");
    return count;
  }

  Future<int> pruneOldVideos(DateTime cutoff) async {
    // Deletes videos available before the cutoff time
    final cutoffIso = cutoff.toIso8601String();
    final count = await (delete(cachedVideos)..where((t) => t.availableAt.isSmallerThanValue(cutoffIso))).go();
    // TODO: Use actual logger
    print("Pruned $count videos older than $cutoffIso.");
    return count;
  }

  // --- Status/State Updates ---

  Future<void> updateVideoStatusInternal(String id, String newStatus) {
    return (update(cachedVideos)..where((t) => t.videoId.equals(id))).write(CachedVideosCompanion(status: Value(newStatus)));
  }

  Future<void> updateScheduledNotificationIdInternal(String id, int? notificationId) {
    return (update(cachedVideos)
      ..where((t) => t.videoId.equals(id))).write(CachedVideosCompanion(scheduledLiveNotificationId: Value(notificationId)));
  }

  Future<void> updateLastLiveNotificationTimeInternal(String id, DateTime? time) {
    final timestamp = time?.millisecondsSinceEpoch; // Convert DateTime to nullable int timestamp
    return (update(cachedVideos)..where((t) => t.videoId.equals(id))).write(CachedVideosCompanion(lastLiveNotificationSentTime: Value(timestamp)));
  }

  Future<void> setPendingNewMediaFlagInternal(String id, bool isPending) {
    return (update(cachedVideos)..where((t) => t.videoId.equals(id))).write(CachedVideosCompanion(isPendingNewMediaNotification: Value(isPending)));
  }

  // --- Scheduled Video Queries (Used by UI) ---

  Future<List<CachedVideo>> getScheduledVideosInternal() {
    return (select(cachedVideos)
          ..where((tbl) => tbl.scheduledLiveNotificationId.isNotNull() | tbl.scheduledReminderNotificationId.isNotNull())
          ..orderBy([
            // Order by reminder time if it exists, otherwise by live schedule time
            (t) => OrderingTerm.asc(
              CustomExpression<int>(
                "CASE WHEN scheduled_reminder_notification_id IS NOT NULL THEN scheduled_reminder_time ELSE CAST(strftime('%s', start_scheduled) * 1000 AS INTEGER) END",
                precedence: Precedence.primary, // Needed for CASE WHEN
              ),
            ),
          ]))
        .get();
  }

  Stream<List<CachedVideo>> watchScheduledVideosInternal() {
    return (select(cachedVideos)
          ..where((tbl) => tbl.scheduledLiveNotificationId.isNotNull() | tbl.scheduledReminderNotificationId.isNotNull())
          ..orderBy([
            // Order by reminder time if it exists, otherwise by live schedule time
            (t) => OrderingTerm.asc(
              CustomExpression<int>(
                "CASE WHEN scheduled_reminder_notification_id IS NOT NULL THEN scheduled_reminder_time ELSE CAST(strftime('%s', start_scheduled) * 1000 AS INTEGER) END",
                precedence: Precedence.primary, // Needed for CASE WHEN
              ),
            ),
          ]))
        .watch();
  }

  Future<List<CachedVideo>> getVideosWithScheduledRemindersInternal() {
    return (select(cachedVideos)..where((tbl) => tbl.scheduledReminderNotificationId.isNotNull())).get();
  }

  Future<void> updateScheduledReminderNotificationIdInternal(String id, int? notificationId) {
    return (update(cachedVideos)
      ..where((t) => t.videoId.equals(id))).write(CachedVideosCompanion(scheduledReminderNotificationId: Value(notificationId)));
  }

  Future<void> updateScheduledReminderTimeInternal(String id, DateTime? time) {
    final timestamp = time?.millisecondsSinceEpoch;
    return (update(cachedVideos)..where((t) => t.videoId.equals(id))).write(CachedVideosCompanion(scheduledReminderTime: Value(timestamp)));
  }
}

// --- Database Connection Factory ---
LazyDatabase openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'holodex_notifier_db.sqlite'));
    // TODO: Use actual logger
    print("Database file path: ${file.path}");
    return NativeDatabase.createInBackground(
      file,
      logStatements: true, // Enable SQL logging for debug builds
    );
  });
}
